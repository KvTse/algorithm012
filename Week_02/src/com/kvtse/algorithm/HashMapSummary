 * HashMap
      1.默认初始化容量为16,且必须是2的次方,如果指定map大小非2的次方时,会底层会将map的大小置为比参数大的最小2的次方数
        这一点主要是用来优化hash寻址的.
      2.调用构造器创建map时,map容量最大为2的30次方
      3.默认装载因子为0.75
      4.当链表长度达到8时,转成红黑树,当红黑树节点为6时,转成链表
      5.当 hash 碰撞之后写入链表的长度超过了阈值(默认为8)并且 table 的长度不小于64，链表将会转换为红黑树

      Node 内部类 hash桶中的node节点

      方法:
      hash
      static final int hash(Object key) {
       int h;
       拿到对应key的hash值,然后将值右移16位,与原先的hash值做异或运算
       return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
       }
       1111 1111 1111 1111 1101 1011 0100 1100 // 原始hash值
       0000 0000 0000 0000 1111 1111 1111 1111 // 右移16位hash值
       1111 1111 1111 1111 0010 0100 1011 0011 // 异或运算结果
       选址算法 优化:
       (n-1) & hash

       map的put和get方法
       当key-value对中的key进行hash取值之后,根据key的hash值去数组中寻址,找到一个位置将key-value存放到数组中或从数组中取出元素
       如果有多个key的hash值一样,此时发生hash碰撞,此时会调用key的equals方法,如果key的equals返回true则会替换之前的key的value
       如果返回false,会在数组元素的位置挂一个链表,同时放在数组的一个位置.当链表的长度大于8且数组的中长度大于等于64时,链表会树形化
       如果链表的长度过长,查询元素性能较差,时间复杂度为O(n),因为转化成红黑树.

       扩容:2被扩容,rehash






